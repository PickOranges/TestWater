#pragma kernel CS_InitSpectrum
#pragma kernel CS_PackSpectrumConjugate
#pragma kernel CS_UpdateSpectrumForFFT
#pragma kernel CS_HorizontalFFT
#pragma kernel CS_VerticalFFT
#pragma kernel CS_AssembleMaps

#define PI 3.14159265358979323846
#define PI2 6.28318530718
#define g 9.81

#define SIZE 1024
#define LOG_SIZE 10

//RWTexture2DArray<float4> InitSpectrumTexture; 
RWTexture2D<float4> InitSpectrumTexture, SpectrumTexture, DisplacementTexture;
RWTexture2D<float2> SlopeTexture;
                                         
RWTexture2D<float4> ButterflyTexture; // N*log2N
RWTexture2D<float4> IFFTResult;
groupshared float4 fftGroupBuffer[2][SIZE]; // 0: tmp  

float D/* depth */;
float L, _LowCutoff, _HighCutoff;
float _RepeatTime, _FrameTime;
float2 _Lambda;
uint N;


struct SpectrumParameters { // passed from CPU to GPU, also user can adjust those params for 8 spectrums respectively.
	float scale;
	float angle;
	float spreadBlend;
	float swell;
	float alpha;
	float peakOmega;
	float gamma;
	float shortWavesFade;
    float windSpeed;
};

StructuredBuffer<SpectrumParameters> Sps;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float tanhvalue(float kD){ // k: length/magnitute of vector k=[kx, kz]
    return tanh(min(kD, 3));        // original: 20, idk why?
    //return tanh(min(kD, 20));        
}

float Frequency(float k, float tanhv){ 
   return sqrt(g*k*tanhv);
}

float FrequencyDerivative(float kD, float tanhv, float freq){  // length/magnitute of w(k)
    float sech2=pow(1/cosh(kD),2);
    return 0.5*g*(kD*sech2 + tanhv) / freq;
}

float Gaussian(float x){ // seed
    return exp(-0.5*x*x)/sqrt(2*PI);
}

// ???
// Todo: check both
float hash(uint n) {
    // integer hash copied from Hugo Elias
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

// ???
float2 UniformToGaussian(float u1, float u2) { // ??? what is u1, u2, R, theta
    float R = sqrt(-2.0f * log(u1));  // log: base-e, i.e. ln(..)
    float theta = 2.0f * PI * u2;

    return float2(R * cos(theta), R * sin(theta));
}

// eq 28
float JONSWAP(SpectrumParameters sp, float w /* freq */){
    float sigma = (w<=sp.peakOmega) ? 0.07 : 0.09;
    float r = exp(- (w-sp.peakOmega)*(w-sp.peakOmega) / 2 / sigma / sigma / sp.peakOmega / sp.peakOmega ); // Why zero ????
    float r1 = exp( (w-sp.peakOmega)*(w-sp.peakOmega) / 2 / sigma / sigma / sp.peakOmega / sp.peakOmega ); 
    float w_repri=1/w;
    return sp.alpha * g * g * pow(w_repri,5) * exp(-1.25 * pow(sp.peakOmega/w, 4)) * pow(3.3, r1) ;  // ????
}

// eq 30
float TMA_phi(float w){  
    float wh = w*sqrt(D/g);

    if(wh<=1.0) return 0.5*wh*wh;
    if(wh<=2.0) return 1-0.5*(2-wh)*(2-wh);
    return 1.0;
}




//// formula (30), and the formula before (30)
//float TMACorrection(float omega) {
//	float omegaH = omega * sqrt(D / g);
//	if (omegaH <= 1.0f)
//		return 0.5f * omegaH * omegaH;
//	if (omegaH < 2.0f)
//		return 1.0f - 0.5f * (2.0f - omegaH) * (2.0f - omegaH);

//	return 1.0f;
//}

//// formula (30), TMA modified JONSWAP
//float JONSWAP(float omega, SpectrumParameters spectrum) {
//	float sigma = (omega <= spectrum.peakOmega) ? 0.07f : 0.09f;    // JONSWAP wiki: sigma1=0.07, sigma2=0.09

//	float r = exp(-(omega - spectrum.peakOmega) * (omega - spectrum.peakOmega) / 2.0f / sigma / sigma / spectrum.peakOmega / spectrum.peakOmega);
	
//	float oneOverOmega = 1.0f / omega;
//	float peakOmegaOverOmega = spectrum.peakOmega / omega;
//	return spectrum.scale * TMACorrection(omega) * spectrum.alpha * g * g   // why is the formula different from eq(28) ???
//		* oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega
//		* exp(-1.25f * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega)
//		* pow(abs(spectrum.gamma), r);
//}





// TODO: optimised GPU parallel version
float EulerGamma(float s){
    float res=1;
    for(int i=1; i<=s; ++i) res*=i;
    return res;
}

// eq 34
float Q(float s){  
    return pow(2, 2*s-1)/PI * pow(EulerGamma(s+1),2) / EulerGamma(2*s+1);
}

// eq 33 & 44, but they use different s.
float MitsuyasuDS(float w, float theta, float s){
    return Q(s) * pow(abs(cos(theta*0.5)), 2*s);
}

// eq 37
float ShapingParameter(SpectrumParameters sp, float w){
    float a=w/sp.peakOmega;
    if(w<=sp.peakOmega) return 6.97*pow(abs(a),4.06); 
    return 9.77*pow(abs(a),-2.33-1.45*(sp.windSpeed*sp.peakOmega/g)-1.17); 
}

// eq 45
float ShapingParameterSksi(SpectrumParameters sp, float w){
    return 16*tanh(sp.peakOmega/w)*sp.swell*sp.swell;
}

float NormalizationFactor(float s) { 
    float s2 = s * s;
    float s3 = s2 * s;
    float s4 = s3 * s;
    if (s < 5) return -0.000564f * s4 + 0.00776f * s3 - 0.044f * s2 + 0.192f * s + 0.163f;
    else return -4.80e-08f * s4 + 1.07e-05f * s3 - 9.53e-04f * s2 + 5.90e-02f * s + 3.93e-01f;
}

float Cosine2s(float theta, float s) {
	return NormalizationFactor(s) * pow(abs(cos(0.5f * theta)), 2.0f * s);
}

float SpreadPower(float omega, float peakOmega) {
	if (omega > peakOmega)
		return 9.77f * pow(abs(omega / peakOmega), -2.5f);
	else
		return 6.97f * pow(abs(omega / peakOmega), 5.0f);
}

// finalD = D_base + D_ksi, paper P36 left-bottom.
float finalDirectionalSpread(SpectrumParameters sp, float w, float theta){
    //float s=ShapingParameter(sp,w);
    //float sksi=ShapingParameterSksi(sp,w);

    //float Dbase=MitsuyasuDS(w,theta,s);
    //float Dksi=MitsuyasuDS(w,theta,sksi);
    
    //return Dbase+Dksi;
    //return lerp(2.0f / 3.1415f * cos(theta) * cos(theta), Dbase+Dksi, sp.spreadBlend);

    float s = SpreadPower(w, sp.peakOmega) + 16 * tanh(min/* ??? why min */(w / sp.peakOmega, 20)) * sp.swell * sp.swell;
    return lerp(2.0f / 3.1415f * cos(theta) * cos(theta), Cosine2s(theta - sp.angle, s), sp.spreadBlend);
}

// attenuation
float ShortWavesFade(SpectrumParameters sp, float kLength) {
	return exp(-sp.shortWavesFade * sp.shortWavesFade * kLength * kLength);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float2 ComplexMult(float2 a, float2 b) {
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

float2 ComplexExp(float2 a)
{
	return float2(cos(a.y), sin(a.y)) * exp(a.x);
}

float2 EulerFormula(float x) {
    return float2(cos(x), sin(x));
}

[numthreads(8,8,1)] 
void CS_InitSpectrum (uint3 id : SV_DispatchThreadID)
{
    uint seed=N*id.y + id.x + N;

    float halfN = N/2;  // we use a square spectrum, instead of rectangular.
    float dk=2*PI/L;  
    float2 k=(id.xy-halfN)*dk;
    float kLength=length(k); 

    float seed1= 0.0 + hash(seed) * 10;
    //float seed2= 1.0 + hash(seed) * 10;

    float4 uniformRandSamples = float4(hash(seed1), hash(seed1 * 2), hash(seed1 * 3), hash(seed1 * 4)); // use one seed to generate 4 seeds
    float2 gauss1 = UniformToGaussian(uniformRandSamples.x, uniformRandSamples.y);
    float2 gauss2 = UniformToGaussian(uniformRandSamples.z, uniformRandSamples.w);

    //float2 gauss=UniformToGaussian(uniformRandSamples.x, uniformRandSamples.y);
    float2 gauss=float2(gauss2.x, gauss1.y);

    float theta = atan2(k.y, k.x);
    float tanhval = tanhvalue(kLength);
    float w=Frequency(kLength,tanhval);
    float dw=FrequencyDerivative(kLength, tanhval, w);


    if(kLength<_LowCutoff || kLength>_HighCutoff){
        //InitSpectrumTexture[uint3(id.xy,0)]=float4(0,0,1,0);
        InitSpectrumTexture[id.xy]=float4(0,0,1,0);
    }
    else{
        float spectrum = TMA_phi(w) * JONSWAP(Sps[0],w) * finalDirectionalSpread(Sps[0],w,theta) * ShortWavesFade(Sps[0],kLength);
        //float spectrum = JONSWAP(w, Sps[0]) * finalDirectionalSpread(Sps[0],w,theta) * ShortWavesFade(Sps[0],kLength);
        InitSpectrumTexture[id.xy]=float4(gauss * sqrt(2*spectrum * abs(dw) / kLength * dk *dk), 0.0, 0.0); 
        //InitSpectrumTexture[id.xy]=float4(spectrum, 0.0, 0.0, 0.0);
    }
}

[numthreads(8,8,1)]
void CS_PackSpectrumConjugate(uint3 id : SV_DISPATCHTHREADID) {
    //for (uint i = 0; i < 4; ++i) {
        float2 h0 = InitSpectrumTexture[id.xy].rg;
        float2 h0conj = InitSpectrumTexture[uint2((N - id.x ) % N, (N - id.y) % N)].rg;  
        InitSpectrumTexture[id.xy] = float4(h0, h0conj.x, -h0conj.y); 
    //}
}

void TwiddleFactorAndInputIndices(uint x/* stage-1 */, uint y/* input index */, out uint2 indices/* i, i+b */, out float2 twiddle){
    uint b = N>>(x+1);
    uint i = (2 * b * (y / b) + y % b) % N;
    float2 mult = PI2 * float2(0,1)/N;
	twiddle = ComplexExp(-mult * ((y / b) * b));
	ButterflyTexture[uint2(x,y)] = float4(twiddle.x, twiddle.y, i, i + b);
	ButterflyTexture[uint2(x, y + N / 2)] = float4(-twiddle.x, -twiddle.y, i, i + b);
}

void ButterflyValues(uint step, uint index, out uint2 indices, out float2 twiddle) {
    const float twoPi = 6.28318530718;
    uint b = SIZE >> (step + 1);        
                                      
    uint w = b * (index / b);  
                               
    uint i = (w + index) % SIZE; 
    sincos(-twoPi / SIZE * w, twiddle.y, twiddle.x);    

    twiddle.y = -twiddle.y; 
    indices = uint2(i, i + b);      
}

float4 FFT(uint threadIndex, float4 input){
    fftGroupBuffer[0][threadIndex] = input; 
    GroupMemoryBarrierWithGroupSync();  
    bool flag = false;

    [unroll]
    for (uint step = 0; step < LOG_SIZE; ++step) {  
        uint2 inputsIndices;  
        float2 twiddle;
        ButterflyValues(step, threadIndex, inputsIndices, twiddle);

        float4 v = fftGroupBuffer[flag][inputsIndices.y];  
        fftGroupBuffer[!flag][threadIndex] = fftGroupBuffer[flag][inputsIndices.x] + float4(ComplexMult(twiddle, v.xy), ComplexMult(twiddle, v.zw));

        flag = !flag;  
        GroupMemoryBarrierWithGroupSync();
    }

    return fftGroupBuffer[flag][threadIndex];
}

[numthreads(SIZE, 1, 1)]  // N*1, id.x=0...N-1, id.y=const.
void CS_HorizontalFFT(uint3 id : SV_DISPATCHTHREADID) {
    IFFTResult[id.xy] = FFT(id.x, IFFTResult[id.xy]);  
}

[numthreads(SIZE, 1, 1)]  // 1*N, id.y=0...N-1, id.x=const.
void CS_VerticalFFT(uint3 id : SV_DISPATCHTHREADID) {
    IFFTResult[id.yx] = FFT(id.x, IFFTResult[id.yx]);
}

[numthreads(8, 8, 1)] 
void CS_UpdateSpectrumForFFT(uint3 id : SV_DISPATCHTHREADID) {
        float4 initialSignal = InitSpectrumTexture[id.xy];
        float2 h0 = initialSignal.xy;
        float2 h0conj = initialSignal.zw;

        float halfN = N / 2.0f;
        float2 K = (id.xy - halfN) * 2.0f * PI / L;  
        float kMag = length(K);
        float kMagRcp = rcp(kMag);  

        if (kMag < 0.0001f) {
            kMagRcp = 1.0f;
        }

        float w_0 = 2.0f * PI / _RepeatTime;    
        float dispersion = floor(sqrt(g * kMag) / w_0) * w_0 * _FrameTime;
        float2 exponent = EulerFormula(dispersion);

        float2 htilde = ComplexMult(h0, exponent) + ComplexMult(h0conj, float2(exponent.x, -exponent.y));
        float2 ih = float2(-htilde.y, htilde.x);

        // P i.e. height map, Tessendorf paper formula (44)
        float2 displacementX = ih * K.x * kMagRcp;  // similar to Gerstner Wave formula, x is perpendicular to y, and * x/k. 
                                                    // (see catlike water tutorial 3) P = ...
                                                    // Because Gerstner Wave is just one special case of this spectrum function.
        float2 displacementY = htilde;
        float2 displacementZ = ih * K.y * kMagRcp;  // reason is the same as x

        // T i.e. Tangent
        float2 displacementX_dx = -htilde * K.x * K.x * kMagRcp; // (same as above)see catlike T=..., also check the formula inside the shader code
        float2 displacementY_dx = ih * K.x;                      // same as above
        float2 displacementZ_dx = -htilde * K.x * K.y * kMagRcp; // same as above

        // B i.e. Bitangent or Binormal
        // float2 displacementX_dz = -htilde * K.x * K.y * kMagRcp; // this is the same as displacementZ_dx, thus dont have to re-calculate.
        float2 displacementY_dz = ih * K.y;      
        float2 displacementZ_dz = -htilde * K.y * K.y * kMagRcp;

        float2 htildeDisplacementX = float2(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x);       // Dx_Dz[id.xy]
        float2 htildeDisplacementZ = float2(displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x); // Dy_Dxz[id.xy]
        
        float2 htildeSlopeX = float2(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x); // Dyx_Dyz[id.xy]
        float2 htildeSlopeZ = float2(displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x); // Dxx_Dzz[id.xy]

        SpectrumTexture[id.xy] = float4(htildeDisplacementX, htildeDisplacementZ);
        SpectrumTexture[id.xy] = float4(htildeSlopeX, htildeSlopeZ);
}

[numthreads(8, 8, 1)]
void CS_AssembleMaps(uint3 id : SV_DISPATCHTHREADID) {
    float4 htildeDisplacement = SpectrumTexture[id.xy];  
    float4 htildeSlope = SpectrumTexture[id.xy]; 

    float2 dxdz = htildeDisplacement.rg;
    float2 dydxz = htildeDisplacement.ba;
    float2 dyxdyz = htildeSlope.rg;
    float2 dxxdzz = htildeSlope.ba;
        
    float jacobian = (1.0f + _Lambda.x * dxxdzz.x) * (1.0f + _Lambda.y * dxxdzz.y) - _Lambda.x * _Lambda.y * dydxz.y * dydxz.y;
    float3 displacement = float3(_Lambda.x * dxdz.x, dydxz.x, _Lambda.y * dxdz.y);
    float2 slopes = dyxdyz.xy / (1 + abs(dxxdzz * _Lambda));
    float covariance = slopes.x * slopes.y;

    DisplacementTexture[id.xy] = float4(displacement, 0.0);
    SlopeTexture[id.xy] = float2(slopes);
}

