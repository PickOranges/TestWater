#pragma kernel CS_InitSpectrum

#define PI 3.14159265358979323846
#define g 9.81

RWTexture2D<float4> InitSpectrumTexture;  // Why not this one ??? What's the difference ??? array: an array of RWTexture2D, i.e. allow pass multiple texs. 
                                            // Useful for terrain.
//RWTexture2DArray<float4> InitSpectrumTexture; 

float D/* depth */;
float L, _LowCutoff, _HighCutoff;
uint N;

struct SpectrumParameters { // passed from CPU to GPU, also user can adjust those params for 8 spectrums respectively.
	float scale;
	float angle;
	float spreadBlend;
	float swell;
	float alpha;
	float peakOmega;
	float gamma;
	float shortWavesFade;
    float windSpeed;
};

StructuredBuffer<SpectrumParameters> Sps;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float tanhvalue(float kD){ // k: length/magnitute of vector k=[kx, kz]
    return tanh(min(kD, 3));        // original: 20, idk why?
}

float Frequency(float k, float tanhv){ 
   return sqrt(g*k*tanhv);
}

float FrequencyDerivative(float kD, float tanhv, float freq){  // length/magnitute of w(k)
    float sech2=pow(1/cosh(kD),2);
    return 0.5*g*(kD*sech2 + tanhv) / freq;
}

float Gaussian(float x){ // seed
    return exp(-0.5*x*x)/sqrt(2*PI);
}

// ???
// Todo: check both
float hash(uint n) {
    // integer hash copied from Hugo Elias
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

// ???
float2 UniformToGaussian(float u1, float u2) { // ??? what is u1, u2, R, theta
    float R = sqrt(-2.0f * log(u1));  // log: base-e, i.e. ln(..)
    float theta = 2.0f * PI * u2;

    return float2(R * cos(theta), R * sin(theta));
}

// eq 28
float JONSWAP(SpectrumParameters sp, float w /* freq */){
    float sigma = (w<=sp.peakOmega) ? 0.07 : 0.09;
    float r = exp( -pow(w-sp.peakOmega, 2) / (2*pow(sigma*sp.peakOmega,2)) );

    return sp.alpha*g*g/pow(w,5) * exp(-1.25 * pow(sp.peakOmega/w, 4)) * pow(3.3, 4);
}

// eq 30
float TMA_phi(float w){  
    float wh = w*sqrt(D/g);
    float phi = wh<=1 ? 0.5*wh*wh : 1-0.5*(2-wh)*(2-wh);
    return phi;
}

// TODO: optimised GPU parallel version
float EulerGamma(float s){
    float res=1;
    for(int i=1; i<=s; ++i) res*=i;
    return res;
}

// eq 34
float Q(float s){  
    return pow(2, 2*s-1)/PI * pow(EulerGamma(s+1),2) / EulerGamma(2*s+1);
}

// eq 33 & 44, but they use different s.
float MitsuyasuDS(float w, float theta, float s){
    return Q(s) * pow(abs(cos(theta/2)), 2*s);
}

// eq 37
float ShapingParameter(SpectrumParameters sp, float w){
    float a=w/sp.peakOmega;
    if(w<=sp.peakOmega) return 6.97*pow(abs(a),4.06); 
    return 9.77*pow(abs(a),-2.33-1.45*(sp.windSpeed*sp.peakOmega/g)-1.17); 
}

// eq 45
float ShapingParameterSksi(SpectrumParameters sp, float w){
    return 16*tanh(sp.peakOmega/w)*sp.swell*sp.swell;
}

// finalD = D_base + D_ksi, paper P36 left-bottom.
// Q: why lerp in original code ???
float finalDirectionalSpread(SpectrumParameters sp, float w, float theta){
    float s=ShapingParameter(sp,w);
    float sksi=ShapingParameterSksi(sp,w);

    float Dbase=MitsuyasuDS(w,theta,s);
    float Dksi=MitsuyasuDS(w,theta,sksi);
    
    return Dbase+Dksi;
}

// attenuation
float ShortWavesFade(SpectrumParameters sp, float kLength) {
	return exp(-sp.shortWavesFade * sp.shortWavesFade * kLength * kLength);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//[numthreads(8,8,1)]
//void CSMain (uint3 id : SV_DispatchThreadID)
//{
    

//    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
//}

[numthreads(8,8,1)]
void CS_InitSpectrum (uint3 id : SV_DispatchThreadID)
{
    //InitSpectrumTexture[uint3(id.xy,0)] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0); // something wrong with read back to CPU side ???
    //InitSpectrumTexture[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0); // something wrong with read back to CPU side ???
    //return;

    uint seed=N*id.y + id.x + N;

    float halfN = N/2;  // we use a square spectrum, instead of rectangular.
    float dk=2*PI/L;  
    float2 k=(id.xy-halfN)*dk;
    float kLength=length(k); 

    float seed1= 0.0 + hash(seed) * 10;
    float seed2= 1.0 + hash(seed) * 10;
    float2 uniformSample=float2(hash(seed1), hash(seed2));
    float2 gauss=UniformToGaussian(uniformSample.x, uniformSample.y);

    float theta = atan2(k.y, k.x);
    float tanhval = tanhvalue(kLength);
    float w=Frequency(kLength,tanhval);
    float dw=FrequencyDerivative(kLength, tanhval, w);


    if(kLength<_LowCutoff || kLength>_HighCutoff){
        //InitSpectrumTexture[uint3(id.xy,0)]=float4(0,0,1,0);
        InitSpectrumTexture[id.xy]=float4(0,0,1,0);
    }
    else{
        float spectrum = TMA_phi(w) * JONSWAP(Sps[0],w) * finalDirectionalSpread(Sps[0],w,theta) * ShortWavesFade(Sps[0],kLength);
        //InitSpectrumTexture[uint3(id.xy,0)]=float4(gauss * sqrt(2*spectrum * abs(dw) / kLength * dk *dk), 0.0, 0.0); 
        //InitSpectrumTexture[uint3(id.xy,0)]=float4(0,1,0,0);
        InitSpectrumTexture[id.xy]=float4(gauss * sqrt(2*spectrum * abs(dw) / kLength * dk *dk), 0.0, 0.0); 
    }
}

